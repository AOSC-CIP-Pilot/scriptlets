#!/bin/bash
# cp-wrapper: Determines if we are doing the cp job in the same fs.
# If so, add '-l' to cp.
# Arguments from cp (GNU coreutils) 8.23, therefore:
# @license GPL-3.0+


declare -A mount_state
# initialization: mtab
IFS=' '
while read fs mpoint type opts dump pass; do
	mpoint="$(echo -e "${mpoint%/}-")"
	mpoint="${mpoint%-}"
	[[ fs == *fs ]] || fs="$(readlink -e "$fs")"
	mount_state["$mpoint"]="${fs%/} $type $opts $dump $pass"
done < /etc/mtab
IFS=$' \t\n'

# argument processing
gopt="$(getopt -o abdfiHlLnPpRrsStTuvxZ \
--long archive,attributes-only,backup:,copy-contents,force,interactive,link,dereference,no-clobber,no-dereference,\
preserve:,no-preserve:,parents,recursive,reflink:,remove-destination,sparse:,strip-trailing-slashes,\
symbolic-link,suffix:,target-directory:,no-target-directory,update,verbose,one-file-system,context:,help,version \
-n "$0" -- "$@")" || exit $?
eval gopt="($gopt)"
gargc=${#gopt[@]}

for ((f=0; f<gargc; f++)); do
	case "${gopt[f]}" in
		--)	break;;
		-t|--target-directory)  # target dir
			files=("${gopt[f+1]}");; # only consider last one
		--target-directory=*)   # ditto
			files=("${gopt[f]#--target-directory=");;
	esac
done

samefs=1
curpoint=''
files+=("${gopt[@]:f+1}")
gopt=("${gopt[@]:0:f}")
# iterate through all files.
# `cp -l` works if all source and destination are in the same fs,
# comparing with the previous one effectively tells us if they are all the same.

# todo: we should actually sort things into l-buckets and non-l-buckets
for o in "${file[@]}"; do
	o=$(readlink -m "${o}")x o=${o%x}
	while [[ -n "${mount_state[$o]}" && "$o" ]]; do
		o="${o%/*}"
	done
	if [[ -n "${mount_state[$o]}" ]]; then
		samefs=0 # dontknow.
		break
	elif [[ -n "$curpoint" ]]; then
		curstate="${mount_state[$o]}"
	elif [[ "${mount_state[$o]}" != "$curstate" ]]; then
		samefs=0
		break
	fi
done

((samefs)) && gopt+=("-l")

exec cp "${gopt[@]}" -- "${file[@]}"
